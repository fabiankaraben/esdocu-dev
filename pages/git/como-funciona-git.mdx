---
description: Git es una herramienta con muchas funciones, comandos y opciones, pero si logras crear el modelo mental adecuado, evitar√°s mucha confusi√≥n y frustraci√≥n.
---
# ¬øC√≥mo funciona Git?

En esta lecci√≥n, crearemos una imagen imaginaria de c√≥mo funciona Git, el llamado modelo mental.

Tener el modelo mental correcto es crucial. Git es una herramienta compleja con muchas funciones, comandos y opciones, pero si logras crear el modelo mental adecuado, evitar√°s mucha confusi√≥n y frustraci√≥n al trabajar con Git.

Esta imagen imaginaria de c√≥mo funciona Git no tiene por qu√© ser 100% precisa ni cubrir todos los detalles. Simplemente tiene que ayudarte a comprender el estado en el que se encuentra tu proyecto y predecir qu√© suceder√° cuando ejecutes un determinado comando.

Puedes utilizar varios modelos mentales para pensar en lo mismo. Cada modelo te ayudar√° a comprender un aspecto diferente del tema que intentas comprender. A lo largo de este curso, sugerir√© algunas formas de imaginar c√≥mo funciona Git en diferentes situaciones.

As√≠ que aqu√≠ est√° el primer modelo mental: un juego de mesa de carreras. Algunos ejemplos de juegos de mesa de carreras son Snakes and Ladders, Game of the Goose y Monopoly. La cuesti√≥n es que tienes un tablero con casillas y una pieza que mueves por el tablero.

        <br /><br />

```mermaid
---
title: Ejemplo de juego de mesa
---
flowchart LR;
    S((Inicio))
    F((Final))
    A(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
    B(&nbsp;&nbsp;<span class="text-3xl">ü•ú</span>&nbsp;&nbsp;)
    C(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
    D(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
    E(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
    S---A
    A-->B
    B-->C
    C-->D
    D-->E
    E---F
```

        <br /><br />

Ahora relacionemos esta imagen con Git, el sistema de control de versiones distribuido.

## ¬øQu√© es Control de Versiones? [#que-es-control-de-versiones]

Los **Sistemas de Control de Versiones** (VCS) te permiten realizar un seguimiento de los cambios en tu c√≥digo a lo largo del tiempo. Cada vez que realizas cambios, puedes crear una instant√°nea del nuevo estado de tu proyecto.

Esto tambi√©n es similar a las ranuras para guardar en un videojuego. Puedes guardar el juego en cualquier momento y luego volver a ese punto m√°s tarde.

Estas instant√°neas ser√°n nuestras casillas en el tablero. A diferencia del juego de mesa, donde todos los cuadrados se crean de antemano, en el control de versiones creamos los cuadrados sobre la marcha.

        <br /><br />

```mermaid
---
title: Modelo de Git como un juego de mesa
---
flowchart LR;
    A(&nbsp;<span class="text-xs">fj3s...</span>&nbsp;)
    B(&nbsp;<span class="text-xs">f4k3...</span>&nbsp;)
    C(&nbsp;<span class="text-xs">34b3...</span>&nbsp;)
    D(<span class="text-3xl">ü•ú</span><br/><span class="text-xs">d8ne...</span> <strong>HEAD</strong>)
    E(&nbsp;<span class="text-xs !text-gray-500">Nuevo commit</span>&nbsp;)
    A-->B
    B-->C
    C-->D
    D-->E
```

        <br /><br />

Cuando guardamos una instant√°nea de nuestro proyecto (creamos un **commit** en t√©rminos de Git), se crea un nuevo cuadrado y nuestra pieza se mueve all√≠ autom√°ticamente.

Ahora podemos volver a cualquiera de los cuadrados anteriores y ver c√≥mo era el proyecto en ese momento.

Tambi√©n es similar a la funci√≥n **deshacer/rehacer** de un editor de texto o de un programa de dibujo, pero es m√°s potente. Con **deshacer/rehacer**, generalmente est√°s limitado a un cambio a la vez y si comienzas a realizar cambios despu√©s de deshacer algo, perder√°s los cambios que deshiciste.

Con el control de versiones, puedes saltar a cualquier punto de la l√≠nea de tiempo y si comienzas a hacer cambios despu√©s de eso, simplemente creas una nueva rama en la l√≠nea de tiempo, por lo que los cambios antiguos seguir√°n ah√≠.

M√°s adelante podr√°s optar por fusionar esta nueva versi√≥n con la l√≠nea de tiempo principal, descartarla o conservarla indefinidamente.

## ¬øQu√© es Control de Versiones Distribuido? [#que-es-control-de-versiones-distribuido]

Git es un Sistema de Control de Versiones Distribuido. Significa que todos los que trabajan en un proyecto tienen una copia del historial completo del proyecto en su computadora.

        <br /><br />

```mermaid
---
title: Sistema de Control de Versiones Distribuido
---
flowchart LR;
    A((<span class="text-6xl m-5">üíª</span>))
    B((<span class="text-6xl m-5">üíª</span>))
    C((<span class="text-6xl m-5">üíª</span>))
    A<--->B
    B<--->C
    C<--->A
```

        <br /><br />

Con la analog√≠a del tablero de juego, significa que todos tienen una copia del tablero y de la pieza. Cuando realizas un cambio en tu tablero, no afecta el tablero de nadie m√°s. Para compartir tus cambios con otras personas, debes decirles expl√≠citamente que se realizaron los cambios.

Lo contrario es un Sistema de Control de Versiones Centralizado. Significa que hay un servidor central que almacena todo el historial del proyecto. Cuando desees realizar un cambio, debes conectarte al servidor y enviarle los cambios. Si deseas volver a una versi√≥n anterior, debes conectarte al servidor y preguntarle c√≥mo era esa versi√≥n en particular.

```mermaid
---
title: Sistema de Control de Versiones Centralizado
---
flowchart TD;
    A((<span class="text-6xl m-5">‚òÅÔ∏è</span>))
    B((<span class="text-6xl m-5">üíª</span>))
    C((<span class="text-6xl m-5">üíª</span>))
    D((<span class="text-6xl m-5">üíª</span>))
    A<--->B
    A<--->C
    A<--->D
```

Para aplicar nuestra analog√≠a con el juego de mesa, es como si hubiera un maestro del juego que se queda con el tablero y la pieza. Cuando quieras hacer un cambio, debes pedirle al maestro del juego que lo haga por ti. Si quieres volver a una versi√≥n anterior, le pides al director del juego que mueva la pieza y te env√≠e el tablero actualizado.

Para ser honesto, la mayor√≠a de las veces Git se usa con un servidor central (como GitHub o GitLab), aunque puedes compartir los cambios directamente entre tus computadoras.

## ¬øC√≥mo funciona Git? [#como-funciona-git]

Git almacena las instant√°neas de tu trabajo como *commits*. Cada commit contiene una instant√°nea de todo el proyecto. Es similar a guardar una copia de todo el proyecto cada vez que realizas un cambio.

```mermaid
---
title: Instant√°neas incrementales de Git
---
flowchart LR;
    A(<span class="text-3xl">‚©ä</span><br/><span class="text-xs">fj3s...</span>)
    B(<span class="text-3xl">‚Ä¢‚©ä‚Ä¢</span><br/><span class="text-xs">f4k3...</span>)
    C(<span class="text-3xl">^‚Ä¢‚©ä‚Ä¢^</span><br/><span class="text-xs">34b3...</span>)
    D(<span class="text-3xl">‚âΩ^‚Ä¢‚©ä‚Ä¢^‚âº</span><br/><span class="text-xs">d8ne...</span> <strong>HEAD</strong>)
    E(&nbsp;<span class="text-xs !text-gray-500">Nuevo commit</span>&nbsp;)
    A-->B
    B-->C
    C-->D
    D-->E
```

Cada vez que desees conservar el estado de tu proyecto, selecciona los cambios que deseas guardar y crea un commit.

Mira el gr√°fico de arriba. Cada vez que tenemos algunos cambios nuevos, creamos un nuevo commit. Cada commit tiene una identificaci√≥n √∫nica. M√°s tarde podemos usar este ID para volver a el commit.

Adem√°s de almacenar el historial de cambios, Git tambi√©n te permite conservar m√∫ltiples versiones del mismo proyecto. Para ello cuenta con una funcionalidad llamada *branches* o *ramas*.

        <br /><br />

```mermaid
gitGraph
    commit
    commit
    branch bugfix
    commit
    commit
    commit
    checkout main
    commit
    commit tag:"HEAD"
```

        <br /><br />

Una rama es una secuencia de commits. Cuando creas una rama, creas una nueva secuencia de commits a partir de el commit actual.

Puedes crear varias ramas y trabajar en ellas en paralelo. Una vez que hayas terminado con la rama en particular, puedes volver a fusionarla.

## Git Workflow

Repasemos un flujo de trabajo t√≠pico, en el que creamos un nuevo proyecto, hacemos algunos cambios, los confirmamos y cambiamos entre commits.

Comenzamos con una carpeta vac√≠a llamada `proyecto-ejemplo`. Primero, queremos convertir esta carpeta en un repositorio Git. Para ello ejecutamos el comando `git init` dentro de esta carpeta.

```bash filename="Terminal"
git init
```

```plaintext filename="Salida en la Terminal"
Initialized empty Git repository in /Users/esdocu/Proyectos/proyecto-ejemplo/.git/
```

Ahora tenemos un repositorio Git. Al principio, el repositorio est√° vac√≠o, no contiene ningun commit, pero el `HEAD` ya existe y apunta a la rama `main`.

Puedes ver la rama actual ejecutando el comando `git status`.

```bash filename="Terminal"
git status
```

```plaintext filename="Salida en la Terminal"
On branch main
 
No commits yet
```

Estamos en una rama llamada `main` y a√∫n no hay commits.

Imag√≠nalo como una pieza de juego, por ahora sin casillas en el tablero.

Hagamos algunos cambios en nuestro proyecto para luego guardarlos como commits.

Comenzamos creando un archivo llamado `README.md`, que contendr√° un texto corto.

```bash filename="Terminal"
echo "Solo un texto de ejemplo a escribir en este archivo" > README.md
```

Ahora tenemos un archivo llamado `README.md` en nuestro proyecto. Veamos si Git not√≥ este cambio. Ejecuta el comando `git status`:

```bash filename="Terminal"
git status
```

```plaintext filename="Salida en la Terminal"
On branch main
 
No commits yet
 
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	README.md
 
nothing added to commit but untracked files present (use "git add" to track)
```

El mensaje cambi√≥, ahora dice que tenemos un archivo sin seguimiento. Significa que Git not√≥ que creamos un nuevo archivo, pero a√∫n no est√° incluido en ningun commit.

Para guardar el estado actual del proyecto como un commit, primero debemos seleccionar los cambios que deseamos incluir all√≠. Hacemos esto con el comando `git add`.

Puedes imaginar que el comando `git add` funciona de manera similar a c√≥mo funciona la selecci√≥n de archivos en un administrador de archivos. Selecciona los archivos que deseas incluir en el commit.

En nuestro caso, `README.md` es un archivo nuevo que queremos incluir en nuestra primer commit, por lo que ejecutamos `git add README.md`.

```bash filename="Terminal"
git add README.md
```

Ahora hemos seleccionado los cambios en el archivo, en t√©rminos de Git, hemos preparado los cambios. Consultemos el estado del proyecto:

```bash filename="Terminal"
git status
```

```plaintext filename="Salida en la Terminal"
On branch main
 
No commits yet
 
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   README.md
```

Ahora `README.md` aparece en la secci√≥n *Changes to be committed* (Cambios a confirmar). Significa que los cambios en este archivo se seleccionan para incluirse en el pr√≥ximo commit.

Podemos guardar los cambios con el comando `git commit`. Tambi√©n debemos proporcionar un mensaje para el commit. El mensaje debe describir los cambios que hicimos all√≠.

Si ejecutamos `git commit` sin ning√∫n argumento, Git abrir√° un editor de texto y nos pedir√° que ingresemos el mensaje all√≠. Pero tambi√©n podemos proporcionar el mensaje directamente en la terminal con la opci√≥n `-m`.

```bash filename="Terminal"
git commit -m "A√±ade un archivo README.md"
```

```plaintext filename="Salida en la Terminal"
[main (root-commit) 7c63aa7] A√±ade un archivo README.md
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
```

¬°Voil√°! Hemos creado nuestro primer commit. Podemos ver que este commit tiene un identificador √∫nico `7c63aa7` y tiene un mensaje `A√±ade un archivo README.md`. Git crea autom√°ticamente identificadores √∫nicos para cada commit, de modo que podamos consultarlos m√°s adelante.

        <br /><br />

```mermaid
gitGraph
    commit id:"7c63aa7" tag:"HEAD"
```

        <br /><br />

Ahora nuestro repositorio tiene un commit y HEAD apunta a el. Consultemos el estado del proyecto:

```bash filename="Terminal"
git status
```

```plaintext filename="Salida en la Terminal"
On branch main
nothing to commit, working tree clean
```

Git dice que no hay cambios que realizar. Significa que nada ha cambiado desde la √∫ltima vez que creamos un commit.

Digamos que agregamos otra l√≠nea de texto al archivo.

```bash filename="Terminal"
echo "Una segunda l√≠nea de ejemplo en este archivo" >> README.md
```

Si comprobamos el estado del proyecto veremos que tenemos un archivo modificado.

```bash filename="Terminal"
git status
```

```plaintext filename="Salida en la Terminal"
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   README.md
 
no changes added to commit (use "git add" and/or "git commit -a")
```

Preparar y confirmar los cambios:

```bash filename="Terminal"
git add README.md
git commit -m "A√±ade otra l√≠nea de texto al archivo README.md"
```

```plaintext filename="Salida en la Terminal"
[main a16cd19] A√±ade otra l√≠nea de texto al archivo README.md
 1 file changed, 1 insertion(+)
```

Ahora tenemos dos commits en nuestro proyecto. Podemos ver el historial de commits con el comando git log.

```bash filename="Terminal"
git log --oneline
```

```plaintext filename="Salida en la Terminal"
a16cd19 (HEAD -> main) A√±ade otra l√≠nea de texto al archivo README.md
7c63aa7 A√±ade un archivo README.md
```

Los commits se ordenan del m√°s nuevo al m√°s antiguo. Con los commits m√°s recientes en la parte superior.

Utiliza un indicador `--oneline` para acortar la salida. Muestra solo la primera l√≠nea del mensaje del commit y el hash del commit.

Tambi√©n puedes ver hacia d√≥nde apunta el HEAD.

        <br /><br />

```mermaid
gitGraph
    commit id:"7c63aa7"
    commit id:"a16cd19" tag:"HEAD"
```

        <br /><br />

Volviendo a la analog√≠a del tablero de juego, tenemos un tablero con dos casillas y la pieza est√° en la segunda casilla.

Podemos mover la pieza nuevamente al primer cuadrado con el comando `git checkout`.

```bash filename="Terminal"
git checkout 7c63aa7
```

```plaintext filename="Salida en la Terminal"
Note: switching to '7c63aa7'.
```

Esto restablecer√° el contenido de la carpeta de tu proyecto al estado del primer commit.

        <br /><br />

```mermaid
gitGraph
    commit id:"7c63aa7" tag:"HEAD"
    commit id:"a16cd19"
```

        <br /><br />

Si comprobamos el contenido del archivo `README.md` veremos que s√≥lo contiene la primera l√≠nea de texto.

```bash filename="Terminal"
cat README.md
```

```plaintext filename="Salida en la Terminal"
Solo un texto de ejemplo a escribir en este archivo
```

Tambi√©n podemos ver que `HEAD` apunta al primer commit.

```bash filename="Terminal"
git log main --oneline
```

```plaintext filename="Salida en la Terminal"
a16cd19 (main) A√±ade otra l√≠nea de texto al archivo README.md
7c63aa7 (HEAD) A√±ade un archivo README.md
```

Ahora podemos volver a los √∫ltimos cambios usando el comando `git checkout`:

```bash filename="Terminal"
git checkout a16cd19
```

```plaintext filename="Salida en la Terminal"
Previous HEAD position was 7c63aa7 A√±ade un archivo README.md
HEAD is now at a16cd19 A√±ade otra l√≠nea de texto al archivo README.md
```

Y el texto vuelve a estar completo:

```bash filename="Terminal"
cat README.md
```

```plaintext filename="Salida en la Terminal"
Solo un texto de ejemplo a escribir en este archivo
Una segunda l√≠nea de ejemplo en este archivo
```

Aqu√≠ tienes, esta es la esencia de Git. Puedes crear instant√°neas (commits) de tu proyecto y moverte entre ellas.
